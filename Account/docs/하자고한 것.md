단 멈춰라. 지금 뭘 도입할지 고민하기 전에 해야 할 게 있다.

  ---

  🛑 현재 상황 정리

1. 방금 ShardWorkerPool 구조로 전환했다 → 아직 테스트 안 해봄

2. 이전 성능: p95=7.6s (1000 burst, 직접 트랜잭션)

3. 목표: 50ms 이하

4. 예상 성능 (ShardWorkerPool): p95 ~200-500ms (추정)
   
   즉, 새 구조로 성능 측정도 안 했는데 Redis 도입 고민하는 건 시기상조다.

  ---

  ✅ 내가 제안하는 단계별 접근

  Phase 1: 현재 구조 최적화 (지금 당장 해라)

# application.properties

  quarkus.datasource.jdbc.max-size=60  # 30 → 60으로 증가
  quarkus.datasource.jdbc.min-size=30

  // AccountCommandBus.java
  private static final int NUM_SHARDS = 60;  // 32 → 60으로 증가

  이 두 줄만 바꾸고 다시 테스트해라.
  예상: p95가 200ms 이하로 떨어질 가능성 높다.

  ---

  Phase 2: Stored Procedure (성능 부족 시)

  언제 도입?: Phase 1 테스트 후 p95가 100ms 이상이면

  장점:

- ✅ 구현 간단 (1일 작업)

- ✅ ACID 보장

- ✅ 운영 부담 없음

- ✅ p95 20-40ms 달성 가능
  
  단점:

- ❌ 50ms 목표는 안 될 수도 있음 (하지만 현실적으로 충분)

  ---

  Phase 3: Redis (정말 필요하면)

  언제 도입?: Phase 2로도 성능 안 나오면

  장점:

- ✅ p95 < 3ms

- ✅ 100K+ TPS
  
  단점:

- ❌ 운영 복잡도 ×10 증가

- ❌ Eventual consistency (1-2초 지연)

- ❌ Redis HA + Outbox + Reconciliation 필요

- ❌ 개발 기간 2-3주

- ❌ Over-engineering 위험

  ---

  🎯 내 추천: Stored Procedure 방식

  왜냐면:

1. 50ms 목표가 정말 필수인가?
   - HTS 체결 서버도 평균 10-50ms면 충분
   - 계좌 서버는 100ms도 acceptable
   - "50ms 이하"가 비즈니스 필수 요구사항인지 먼저 확인해라
2. Redis는 Over-engineering
   - 운영 복잡도 너무 높음
   - Eventual consistency로 인한 버그 위험
   - 네가 혼자 관리하기엔 부담
3. Stored Procedure가 현실적
   - 구현 단순
   - ACID 보장으로 안전
   - p95 20-40ms면 실무적으로 충분히 빠름
   - DB만 관리하면 됨

  ---

  🚀 당장 할 일 (우선순위)

1. Connection Pool 증가 (5분 작업)
   
   quarkus.datasource.jdbc.max-size=60
   
   // AccountCommandBus.java
   private static final int NUM_SHARDS = 60;

2. 테스트 실행
   
   ./gradlew :com.hts.account.loadtest.GrpcBurstLoadTest.main

3. 결과 분석
- p95 < 100ms → 성공, 끝
- 100ms < p95 < 200ms → Stored Procedure 도입
- p95 > 200ms → 그때 다시 논의

  ---

  💬 최종 결론

  지금은 아무것도 도입하지 마라.

1. Connection Pool 60으로 증가

2. Shard 60으로 증가

3. 테스트
   
   이 3단계만 하고 결과 보여줘라.
   
   그 다음에 Stored Procedure 할지, Redis 할지 결정한다.
   지금은 성능 측정도 안 했는데 구조 바꾸려는 건 시간 낭비다.
   
   다시 테스트해라. 결과 보고 다음 판단한다.
